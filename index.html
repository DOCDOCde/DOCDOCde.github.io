<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="DOC"><meta name="description" content="blog"><title>DOCblog</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="https://docdocde.github.io/"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?c034ea5bf3796a9ac7ebc5275a60fc0d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">DOCblog</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">首页</a></li><li class="nav-link"><a href="/archives/" target="_self">分类</a></li><li class="nav-link"><a href="/tags/" target="_self">标签</a></li><li class="nav-link"><a href="/about/" target="_self">关于我</a></li></ul></header><section id="container"><ul class="home"><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/08/27/flex/" class="post-link">玩一玩flex布局</a></h2><span class="post-time">2016年8月27日</span><div class="post-content"><h2 id="笔记和总结"><a href="#笔记和总结" class="headerlink" title="笔记和总结"></a>笔记和总结</h2><p>整理自:<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool</a>  </p>
<blockquote>
<h4 id="1-container——-display-flex-inline-flex-（需要加webkit前缀）"><a href="#1-container——-display-flex-inline-flex-（需要加webkit前缀）" class="headerlink" title="1. container——-display:flex | inline-flex | （需要加webkit前缀）"></a>1. container——-display:flex | inline-flex | （需要加webkit前缀）</h4><pre><code>1.1 flex-flow:包含两个值
     1.1.1  flex-direction:什么方向(row)
         row | row-reverse | column | column-reverse;
     1.1.2  flex-wrap:是否换行（nowrap）
         nowrap | wrap | wrap-reverse;
 1.2.1 justify-content:水平方向的分布（flex-start）
     flex-start | flex-end | center | space-between | space-around;
 1.2.2 align-content:竖直方向的分布（flex-start）
     flex-start | flex-end | center | space-between | space-around | stretch;
 1.3 align-items:以什么为基准对齐（flex-start）
     flex-start | flex-end | center | baseline | stretch;
</code></pre><h4 id="2-item"><a href="#2-item" class="headerlink" title="2.item"></a>2.item</h4><pre><code>2 .1 order:顺序（0）
 2 .2 flex:包含三个值（0 1 auto）有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。
     2 .2.1 flex-grow:主轴还有空间剩是否放大（0）
         0|1
     2 .2.2 flex-shrink:主轴还有空间不足是否放缩小（1）
         0|1
     2 .2.3 flex-basis:主轴长度（auto）
 2 .3 align-self:允许单个项目有与其他项目不一样的对齐方式（auto）
     auto | flex-start | flex-end | center | baseline | stretch;
</code></pre></blockquote>
<h2 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h2></div><a href="/2016/08/27/flex/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/08/27/fellAboutNodejs/" class="post-link">NodeJs初体验</a></h2><span class="post-time">2016年8月27日</span><div class="post-content"><p><em>这几天大部分时间可能都是在理解那些概念。因为官网解释全都是英文而且自己英文理解能力也不怎么样，所以就只能从网络上别人的理解里了解。再通过一些小例子验证。现在来说说自己的理解吧！</em></p>
<h2 id="一、阻塞与非阻塞"><a href="#一、阻塞与非阻塞" class="headerlink" title="一、阻塞与非阻塞"></a>一、阻塞与非阻塞</h2><blockquote>
<p>先贴上一个连接吧：<a href="http://www.cnblogs.com/xiaozhi_5638/p/4268613.html#top">http://www.cnblogs.com/xiaozhi_5638/p/4268613.html#top</a></p>
</blockquote>
<p>里面解释得觉得挺符合道理的。不过我感觉。不是因为非阻塞而实现功能，而是因为要实现功能才发生了回调和非阻塞。比如在接到读取文件的请求的时候，为了完成读取就必须要与硬盘I/O但是硬盘就像一个老大爷完全跟不上内存和CPU的速度。所以这里就会有一个时间上的不同。所以就产生了回调，调用一些功能性的函数就会出现这样的时间差。就出现了非阻塞和阻塞的差别。为了实现这个功能只有异步或者多线程，但是多线程在服务器这样的内存资源紧张的地方显然不是很划算。另一个不阻塞的原因是nodejs是以事件为驱动。在我的理解就是，有一些列事情在排队做，但是可以异步的去做，做完了再告诉主 事情结果。主事情再来将这个事情完结。就像小说情节的主线和副线，同时发展。副线发展到一定程度之后会回来影响主线发展。<br><img src="https://cl.ly/2A2R3t2Z3f1l/Image%202016-08-27%20at%209.41.36%20PM.png" alt="阻塞与非阻塞"><br></div><a href="/2016/08/27/fellAboutNodejs/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/08/27/strange/" class="post-link">jQuery里奇怪的事</a></h2><span class="post-time">2016年8月27日</span><div class="post-content"><h2 id="一、事件重复绑定"><a href="#一、事件重复绑定" class="headerlink" title="一、事件重复绑定"></a>一、事件重复绑定</h2><blockquote>
<p>在用jquery做分页的时候。在本页测试分页都没有问题，可是只要进入别的页面再回到博客页，点击下一页的按钮它就会跳转两页。再去一次别的页面回到博客页点击下一页，它就会跳转三页。后来才发现是事件重复绑定惹的祸</p>
</blockquote>
<p><strong>解决办法</strong>： <em>unbind()函数</em><br>规定从指定元素上删除的一个或多个事件处理程序。如果没有规定参数，unbind() 方法会删除指定元素的所有事件处理程序。unbind() 方法移除被选元素的事件处理程序。该方法能够移除所有的或被选的事件处理程序，或者当事件发生时终止指定函数的运行。ubind() 适用于任何通过 jQuery 附加的事件处理程序。<br>代码在\dist\public\js\blog.js</p>
<h2 id="二、DOM对象与jquery对象"><a href="#二、DOM对象与jquery对象" class="headerlink" title="二、DOM对象与jquery对象"></a>二、DOM对象与jquery对象</h2><blockquote>
<p>用$(selector)获取到东西之后使用for进行遍历得到$(selector)[i]，但是当我用$(selector)[i].css之类的语法时就会出错。原来$(selector)是DOM对象，所有无法使用jquery的语法。$(selector)才是jquery对象</p>
</blockquote></div><a href="/2016/08/27/strange/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/08/27/position/" class="post-link">Ajax和position</a></h2><span class="post-time">2016年8月27日</span><div class="post-content"><h2 id="一、Ajax"><a href="#一、Ajax" class="headerlink" title="一、Ajax"></a>一、Ajax</h2><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p>利用javascript通过XMLHttpRequest对象实现数据的异步交互</p>
<p><img src="https://cl.ly/281y473P0f2f/Image%202016-08-27%20at%206.59.46%20PM.png" alt="解析"></p>
<blockquote>
<p>XHR英文全名XmlHttpRequest，中文可以解释为可扩展超文本传输请求。Xml可扩展标记语言，Http超文本传输协议，Request请求  </p>
</blockquote>
<h3 id="试验："><a href="#试验：" class="headerlink" title="试验："></a>试验：</h3></div><a href="/2016/08/27/position/" class="read-more">Read more..</a></article></li><li class="post-item"><article class="post"><h2 class="post-title"><a href="/2016/08/27/think/" class="post-link">这些天学习的一些浅见</a></h2><span class="post-time">2016年8月27日</span><div class="post-content"><blockquote><h2 id="一、关于模板："><a href="#一、关于模板：" class="headerlink" title="一、关于模板："></a>一、关于模板：</h2></blockquote>
<ol>
<li>模板的目的是为了让数据和页面分离。分离之后就有利于相互协作写代码</li>
<li>为了能在html里面写变量常量才需要使用模板引擎</li>
<li>模板引擎名字虽然高大上，但说白了就是在html里面利用正则表达式将模板中定义的关键字找出来。之后再相应的替换成html，因为浏览器最终只能呈现html代码的内容</li>
</ol>
<blockquote><h2 id="二、关于各种语言："><a href="#二、关于各种语言：" class="headerlink" title="二、关于各种语言："></a>二、关于各种语言：</h2></blockquote>
<ol>
<li>并不是规定哪种语言只能干嘛。比如很多Java可以写的也可以用c和c++写。但是因为更适合所以很多人去用某个语言来做相应的东西，所以就给别人印象某个语言是干嘛的</li>
<li>JavaScript就是寻找到html树（我暂时把它叫树，还不知到本来叫什么）里的节点，之后再改变它</li>
<li>浏览器拿到html代码之后就会用dom节点来描绘这个网页的html树，之后再根据css来给这棵树装饰。每个节点都是以一个对象的形式存在，里面有关于它的所有需要的信息，比如上一个节点是什么，下一个节点是什么</li>
</ol></div><a href="/2016/08/27/think/" class="read-more">Read more..</a></article></li></ul><div class="paginator"><a href="/page/2/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div></section><footer><div class="social"><a href="mailto:1324121459@qq.com" class="iconfont icon-email"> </a><a href="https://github.com/DOCDOCde/DOCDOCde.github.io" class="iconfont icon-github"> </a><a href="/atom.xml" class="iconfont icon-rss"> </a></div><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">DOC</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>